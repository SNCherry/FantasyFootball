<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>NFL Fantasy Lineup Generator & Live Draft Assistant</title>
<style>
  :root{
    --bg:#f7f8fa;
    --panel:#ffffff;
    --text:#111;
    --muted:#667085;
    --primary:#0a7cff;
    --ok:#1a9f31;
    --warn:#ff9f0a;
    --bad:#e5484d;
    --chip:#eef2f7;
    --border:#e5e7eb;
    --focus:#94c6ff;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Inter,Arial,sans-serif;
    color:var(--text);
    background:var(--bg);
    line-height:1.35;
  }
  header{
    position:sticky; top:0; z-index:10;
    background:var(--panel); border-bottom:1px solid var(--border);
  }
  .wrap{max-width:1280px;margin:0 auto;padding:12px 16px}
  .titlebar{display:flex;align-items:center;gap:12px;justify-content:space-between}
  .titlebar h1{font-size:20px;margin:0}
  .row{display:flex;gap:8px;flex-wrap:wrap}
  button,.btn{
    appearance:none;border:1px solid var(--border);background:#fff;color:var(--text);
    padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600;
  }
  .btn.primary{background:var(--primary);border-color:var(--primary);color:white}
  .btn.ghost{background:transparent}
  .btn.sm{padding:4px 8px;font-size:12px}
  .btn:focus{outline:3px solid var(--focus);outline-offset:1px}
  .grid{
    display:grid;
    grid-template-columns: 360px 1fr;
    gap:16px;
    padding:16px;
  }
  @media (max-width: 980px){
    .grid{grid-template-columns:1fr}
  }
  .panel{
    background:var(--panel); border:1px solid var(--border); border-radius:12px; padding:12px;
  }
  h2{margin:6px 0 10px; font-size:16px}
  h3{margin:10px 0 6px; font-size:14px}
  label{font-size:14px}
  input,select,textarea{width:100%;padding:8px;border:1px solid var(--border);border-radius:8px;background:white}
  input[type="checkbox"], input[type="radio"]{width:auto}
  input[type="range"]{width:100%}
  small, .muted{color:var(--muted)}
  .helper{display:block;font-size:12px;color:var(--muted);margin-top:4px}
  .tabs{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:8px}
  .tabbtn{padding:8px 10px;border:1px solid var(--border);border-radius:999px;background:#fff;cursor:pointer;font-weight:600}
  .tabbtn.active{background:var(--primary);color:#fff;border-color:var(--primary)}
  .section{display:none}
  .section.active{display:block}
  .twocol{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .chips{display:flex;gap:6px;flex-wrap:wrap}
  .chip{display:inline-flex;gap:6px;align-items:center;background:var(--chip);border:1px solid var(--border);padding:4px 8px;border-radius:999px;font-size:12px}
  .kpi{display:grid;grid-template-columns:repeat(3,1fr);gap:8px}
  .kpi .card{background:var(--panel);border:1px solid var(--border);border-radius:10px;padding:10px}
  .list{display:grid;gap:8px}
  .item{border:1px solid var(--border);border-radius:10px;padding:10px;background:#fff;display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center}
  .meta{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .badges{display:flex;gap:6px;flex-wrap:wrap}
  .badge{font-size:11px;background:var(--chip);border:1px solid var(--border);padding:2px 6px;border-radius:6px}
  .pos-QB{background:#e6f7ff}
  .pos-RB{background:#e9ffe6}
  .pos-WR{background:#fff3e6}
  .pos-TE{background:#f5e6ff}
  .pos-K{background:#fffbe6}
  .pos-DST{background:#e6fff8}
  .scorebar, .probbar{height:8px;border-radius:999px;background:#f0f2f5;overflow:hidden}
  .scorebar span{display:block;height:8px;background:var(--ok)}
  .probbar span{display:block;height:8px;background:var(--primary)}
  details{background:#f9fafb;border:1px dashed var(--border);padding:8px;border-radius:8px}
  .scarcity{display:grid;grid-template-columns:repeat(6,1fr);gap:8px}
  .scar{border:1px solid var(--border);border-radius:8px;padding:8px;background:#fff}
  .scar .bar{height:8px;background:#eef2f7;border-radius:999px;overflow:hidden}
  .scar .bar span{display:block;height:8px;background:var(--warn)}
  table{width:100%;border-collapse:collapse}
  th,td{border-bottom:1px solid var(--border);text-align:left;padding:6px;font-size:13px}
  .toast{position:fixed;right:12px;bottom:12px;z-index:100;background:#111;color:#fff;padding:10px 12px;border-radius:10px;opacity:.95}
  .rowgap{display:grid;gap:8px}
  .inline{display:flex;align-items:center;gap:8px}
  .rightcol .panel{margin-bottom:12px}
  .notice{padding:8px;background:#fff8e6;border:1px solid #ffe2a8;border-radius:8px}
  .pill{padding:2px 8px;border-radius:999px;background:#eef2f7;border:1px solid var(--border);font-size:12px}
  .alert{padding:4px 8px;border-radius:6px;background:#fff0f0;border:1px solid #ffd0d0;color:#a11}
  .lock{cursor:pointer}
  .hl{background:#f0f7ff}
  .divider{height:1px;background:var(--border);margin:8px 0}
  .sr-only{position:absolute;left:-9999px}
  .tip{font-size:12px;color:var(--muted);margin:6px 0}
</style>
</head>
<body>
<header>
  <div class="wrap titlebar">
    <h1>Fantasy Lineup Generator & Live Draft Assistant</h1>
    <div class="row">
      <button class="btn" id="howBtn" aria-controls="how" aria-expanded="false">How this works</button>
      <button class="btn" id="saveBtn" title="Save to browser storage">Save State</button>
      <button class="btn" id="loadBtn" title="Load from browser storage">Load State</button>
      <button class="btn" id="resetSeedBtn" title="Reset to seed data">Reset to seed data</button>
      <button class="btn bad" id="hardResetBtn" title="Clear everything">Quick Reset</button>
    </div>
  </div>
</header>

<main class="wrap grid">
  <!-- LEFT COLUMN -->
  <div>
    <div class="panel">
      <div class="tabs" role="tablist" aria-label="Main">
        <button class="tabbtn active" data-tab="settings" role="tab" aria-selected="true">Settings</button>
        <button class="tabbtn" data-tab="generate" role="tab" aria-selected="false">Generate Plan</button>
        <button class="tabbtn" data-tab="live" role="tab" aria-selected="false">Live Draft</button>
      </div>

      <!-- SETTINGS -->
      <section id="settings" class="section active" role="tabpanel" aria-labelledby="Settings">
        <h2>Draft Strategy</h2>
        <p class="tip">Choose the style of team you want. These options guide how players are ranked.</p>
        <div class="rowgap">
          <div class="twocol">
            <fieldset>
              <legend class="sr-only">Strategy style</legend>
              <label title="Prefer steady weekly points">
                <input type="checkbox" class="strat" value="floor" /> High floor
              </label>
              <small class="helper">Safe and consistent. Fewer bad weeks.</small>

              <label title="Chase big weekly ceilings">
                <input type="checkbox" class="strat" value="upside" /> High upside
              </label>
              <small class="helper">Boom potential. Riskier but higher ceiling.</small>

              <label title="Willing to draft first-year NFL players">
                <input type="checkbox" class="strat" value="rookieTol" /> Rookie tolerance
              </label>
              <small class="helper">Rookies can break out but are less predictable.</small>

              <label title="Comfort drafting players with past injuries">
                <input type="checkbox" class="strat" value="injTol" /> Injury risk tolerance
              </label>
              <small class="helper">More willing to draft players with injury history.</small>

              <label title="Pair your QB with a receiver on the same team">
                <input type="checkbox" class="strat" value="stack" /> Stack QB with WR/TE
              </label>
              <small class="helper">Touchdowns count twice for your lineup when the stack hits.</small>

              <label title="Wait on running backs until later">
                <input type="checkbox" class="strat" value="zeroRB" /> Zero RB
              </label>
              <small class="helper">Load up on WR/TE early. Grab RBs later.</small>

              <label title="Take one elite RB early then wait">
                <input type="checkbox" class="strat" value="heroRB" /> Hero RB
              </label>
              <small class="helper">Anchor with one top RB then focus elsewhere.</small>

              <label title="Wait to draft a quarterback">
                <input type="checkbox" class="strat" value="lateQB" /> Late QB
              </label>
              <small class="helper">Prioritize other positions in early rounds.</small>

              <label title="Keep the roster balanced by position">
                <input type="checkbox" class="strat" value="balanced" checked/> Balanced
              </label>
              <small class="helper">Even spread of talent across positions.</small>
            </fieldset>

            <fieldset>
              <legend>Strategy sliders</legend>
              <label>Floor weight
                <input type="range" id="floorRange" min="0" max="2" step="0.1" value="1" aria-describedby="floorHelp">
              </label>
              <small id="floorHelp" class="helper">Higher prefers consistent players over risky ones.</small>

              <label>Upside weight
                <input type="range" id="upsideRange" min="0" max="2" step="0.1" value="1" aria-describedby="upsideHelp">
              </label>
              <small id="upsideHelp" class="helper">Higher prefers players who can spike big weeks.</small>

              <label>Rookie weight
                <input type="range" id="rookieRange" min="0" max="2" step="0.1" value="1" aria-describedby="rookieHelp">
              </label>
              <small id="rookieHelp" class="helper">Higher increases rookie suggestions.</small>
            </fieldset>
          </div>

          <div class="divider"></div>

          <h2>League Settings</h2>
          <p class="tip">Match these to your league. The draft math and recommendations use these values.</p>
          <div class="twocol">
            <label>Number of teams
              <input id="numTeams" type="number" min="2" max="20" value="12" aria-describedby="teamsHelp">
            </label>
            <small id="teamsHelp" class="helper">Total teams in your league. Commonly 10 or 12.</small>

            <label>Your draft position
              <input id="myPos" type="number" min="1" max="12" value="6" aria-describedby="posHelp">
            </label>
            <small id="posHelp" class="helper">Your pick number in round 1. 1 is first overall.</small>

            <label>Draft type
              <select id="draftType" aria-describedby="typeHelp">
                <option>Snake</option>
                <option>Linear</option>
              </select>
            </label>
            <small id="typeHelp" class="helper">Snake reverses order each round. Linear repeats the same order.</small>

            <label>Rounds
              <input id="numRounds" type="number" min="8" max="24" value="16" aria-describedby="roundsHelp">
            </label>
            <small id="roundsHelp" class="helper">Total draft rounds. Usually starters plus bench.</small>
          </div>

          <h3>Roster</h3>
          <p class="tip">How many starters you must field at each position. FLEX can be RB or WR or TE.</p>
          <div class="twocol" id="rosterCfg">
            <label>QB <input type="number" min="0" max="3" value="1" data-pos="QB" aria-describedby="qbHelp"></label>
            <small id="qbHelp" class="helper">Quarterback - the passer who leads your offense.</small>

            <label>RB <input type="number" min="0" max="6" value="2" data-pos="RB" aria-describedby="rbHelp"></label>
            <small id="rbHelp" class="helper">Running back - rushes and catches short passes.</small>

            <label>WR <input type="number" min="0" max="6" value="3" data-pos="WR" aria-describedby="wrHelp"></label>
            <small id="wrHelp" class="helper">Wide receiver - primary pass catcher.</small>

            <label>TE <input type="number" min="0" max="3" value="1" data-pos="TE" aria-describedby="teHelp"></label>
            <small id="teHelp" class="helper">Tight end - pass catcher who also blocks.</small>

            <label>FLEX <input type="number" min="0" max="4" value="1" data-pos="FLEX" aria-describedby="flexHelp"></label>
            <small id="flexHelp" class="helper">Any RB or WR or TE. Adds lineup flexibility.</small>

            <label>K <input type="number" min="0" max="2" value="1" data-pos="K" aria-describedby="kHelp"></label>
            <small id="kHelp" class="helper">Kicker - scores on field goals and extra points.</small>

            <label>DST <input type="number" min="0" max="2" value="1" data-pos="DST" aria-describedby="dstHelp"></label>
            <small id="dstHelp" class="helper">Defense and special teams - your team's defense unit.</small>

            <label>Bench <input type="number" min="0" max="12" value="6" data-pos="BENCH" aria-describedby="benchHelp"></label>
            <small id="benchHelp" class="helper">Extra players for depth. They do not score unless started.</small>
          </div>

          <div class="divider"></div>

          <h2>Scoring</h2>
          <p class="tip">These settings describe how points are awarded. If you are new, pick a preset.</p>
          <div class="twocol">
            <label>Preset
              <select id="scoringPreset" aria-describedby="scoringPresetHelp">
                <option value="standard">Standard</option>
                <option value="half">Half PPR</option>
                <option value="ppr" selected>PPR</option>
              </select>
            </label>
            <div class="inline">
              <span class="pill">Edit weights below</span>
            </div>
          </div>
          <small id="scoringPresetHelp" class="helper">
            Standard gives no points per catch. Half PPR gives 0.5 per catch. PPR gives 1 per catch.
          </small>
          <div class="rowgap" style="margin-top:6px">
            <table id="scoringTable" aria-label="Scoring weights">
              <thead><tr><th>Stat</th><th>Weight</th></tr></thead>
              <tbody>
                <tr>
                  <td>Passing Yards / pt <small class="muted">How many yards equal 1 point</small></td>
                  <td><input type="number" step="1" id="passYdsPerPt" value="25"></td>
                </tr>
                <tr>
                  <td>Pass TD <small class="muted">Points for a passing touchdown</small></td>
                  <td><input type="number" step="0.1" id="passTD" value="4"></td>
                </tr>
                <tr>
                  <td>Interception <small class="muted">Points lost for throwing a pick</small></td>
                  <td><input type="number" step="0.1" id="int" value="-2"></td>
                </tr>
                <tr>
                  <td>Rushing Yards / pt <small class="muted">Yards run per point</small></td>
                  <td><input type="number" step="1" id="rushYdsPerPt" value="10"></td>
                </tr>
                <tr>
                  <td>Rush TD <small class="muted">Points for a rushing touchdown</small></td>
                  <td><input type="number" step="0.1" id="rushTD" value="6"></td>
                </tr>
                <tr>
                  <td>Receiving Yards / pt <small class="muted">Yards caught per point</small></td>
                  <td><input type="number" step="1" id="recYdsPerPt" value="10"></td>
                </tr>
                <tr>
                  <td>Reception <small class="muted">Points per catch - key to PPR formats</small></td>
                  <td><input type="number" step="0.1" id="rec" value="1"></td>
                </tr>
                <tr>
                  <td>Fumble <small class="muted">Points lost for losing the ball</small></td>
                  <td><input type="number" step="0.1" id="fumble" value="-2"></td>
                </tr>
              </tbody>
            </table>
            <small class="muted">Projected points in the dataset are already per scoring preset. You can still tweak weights for your personal preference.</small>
          </div>

          <div class="divider"></div>

          <h2>Player Data</h2>
          <p class="tip">You can paste a CSV to replace the built-in list. Not required for first-time use.</p>
          <details>
            <summary>CSV Import helper and example</summary>
            <div class="rowgap">
              <p>Paste CSV below, then click Import CSV. Existing dataset will be replaced.</p>
              <pre aria-label="CSV header example"><code>name,team,position,byeWeek,projectedPoints,ADP,tier</code></pre>
              <small class="muted">ADP is average draft position - lower means earlier pick. Tier is a letter grade like S, A, B.</small>
            </div>
          </details>
          <textarea id="csvInput" rows="6" placeholder="Paste player CSV here..."></textarea>
          <small class="helper">Import will validate each row and tell you which line has an issue if it fails.</small>
          <div class="row" style="margin-top:6px">
            <button class="btn" id="importCsvBtn" title="Replace the player pool with your CSV">Import CSV</button>
            <button class="btn" id="exportCsvSeedBtn" title="Download current players as CSV">Export current players CSV</button>
            <button class="btn" id="exportJsonBtn" title="Download your current plan as JSON">Export Plan (JSON)</button>
          </div>

          <div class="divider"></div>

          <h3>Advanced</h3>
          <div class="twocol">
            <label>Availability sigma
              <input id="sigma" type="number" min="4" max="30" value="12" aria-describedby="sigmaHelp">
            </label>
            <small id="sigmaHelp" class="helper">Controls uncertainty around ADP. Higher values mean more randomness in when players get drafted.</small>

            <label>Snipe risk threshold %
              <input id="snipeThresh" type="number" min="1" max="99" value="30" aria-describedby="snipeHelp">
            </label>
            <small id="snipeHelp" class="helper">Warn me if a player's chance to be available at my next pick falls below this percentage.</small>
          </div>

          <div class="divider"></div>
          <button class="btn primary" id="generateBtn" title="Build a pick list and lineup plan">Generate Plan</button>
          <small class="helper">You do not need to import data first. The app ships with a seed dataset.</small>
        </div>
      </section>

      <!-- GENERATE -->
      <section id="generate" class="section" role="tabpanel" aria-labelledby="Generate">
        <div class="rowgap">
          <h2>My Picks by Round</h2>
          <div class="notice">This table shows where you pick each round based on snake logic. Current round and next pick update during Live Draft.</div>
          <table id="picksTable" aria-label="My picks table">
            <thead><tr><th>Round</th><th>My pick</th><th>Overall</th></tr></thead>
            <tbody></tbody>
          </table>

          <h2>Recommended Next Pick</h2>
          <p class="tip">This is the top suggestion after balancing points, position needs, tiers, and chance the player is still on the board.</p>
          <div id="nextPick" class="panel"></div>

          <h2>Top 10 Alternatives</h2>
          <p class="tip">Backups if your top choice gets taken. You can lock a player to keep them in the plan.</p>
          <div id="topAlt" class="list"></div>

          <h2>Full Lineup Plan</h2>
          <p class="tip">Suggested picks across all rounds. Each entry lists a short reason and the player's basics.</p>
          <div id="lineupPlan" class="list"></div>
        </div>
      </section>

      <!-- LIVE -->
      <section id="live" class="section" role="tabpanel" aria-labelledby="Live">
        <div class="rowgap">
          <div class="twocol">
            <div>
              <h2>Add Live Pick</h2>
              <p class="tip">Log players as they are drafted. The tool removes them from your pool and reranks.</p>
              <label>Quick add by name
                <input id="liveSearch" type="text" placeholder="Type player name... (autocomplete)">
              </label>
              <small class="helper">Type at least 3 characters and click Add Pick.</small>
              <div class="row">
                <button class="btn" id="addLiveBtn">Add Pick</button>
                <span id="liveMsg" class="muted"></span>
              </div>
              <div class="divider"></div>
              <div class="twocol">
                <label>By position
                  <select id="livePos">
                    <option value="">Any</option>
                    <option>QB</option><option>RB</option><option>WR</option><option>TE</option><option>K</option><option>DST</option>
                  </select>
                </label>
                <label>By team
                  <select id="liveTeam"></select>
                </label>
              </div>
              <label>Select player
                <select id="livePlayer"></select>
              </label>
              <small class="helper">Use the filters above to narrow the dropdown.</small>
              <div class="row">
                <label>Team slot #
                  <input id="teamIdx" type="number" min="1" value="1" style="max-width:120px" aria-describedby="teamIdxHelp">
                </label>
                <button class="btn" id="addLiveSelBtn">Add Selected</button>
              </div>
              <small id="teamIdxHelp" class="helper">Optional. Track which opposing team drafted the player.</small>
            </div>
            <div>
              <h2>Live Picks</h2>
              <p class="tip">Your running draft log. Undo removes the last entry for that player.</p>
              <table id="liveTable">
                <thead><tr><th>#</th><th>Player</th><th>Team</th><th>Pos</th><th>Bye</th><th>Overall Pick</th><th></th></tr></thead>
                <tbody></tbody>
              </table>
              <div class="divider"></div>
              <h3>Clock</h3>
              <p class="tip">Shows where you are in the draft and how many picks until you are up.</p>
              <div class="kpi">
                <div class="card"><div class="muted">Current round</div><div id="curRound" style="font-size:20px;font-weight:700">1</div></div>
                <div class="card"><div class="muted">Overall pick</div><div id="curPick" style="font-size:20px;font-weight:700">1</div></div>
                <div class="card"><div class="muted">Time to my next pick</div><div id="etaNext" style="font-size:20px;font-weight:700">-</div></div>
              </div>
            </div>
          </div>

          <div class="divider"></div>

          <h2>Best Next Pick</h2>
          <p class="tip">Top choice right now based on who is still available.</p>
          <div id="liveNext" class="panel"></div>
          <h2>Top Alternatives</h2>
          <p class="tip">If the best option gets taken, consider these.</p>
          <div id="liveAlt" class="list"></div>
          <div id="alerts"></div>
        </div>
      </section>
    </div>
  </div>

  <!-- RIGHT COLUMN -->
  <div class="rightcol">
    <div class="panel">
      <h2>Search & Filters</h2>
      <p class="tip">Use these to browse the remaining player pool.</p>
      <div class="twocol">
        <label>Search
          <input id="filterSearch" placeholder="Name, team...">
        </label>
        <label>Position
          <select id="filterPos">
            <option value="">All</option>
            <option>QB</option><option>RB</option><option>WR</option><option>TE</option><option>K</option><option>DST</option>
          </select>
        </label>
        <label>Team
          <select id="filterTeam"></select>
        </label>
        <label>Tier
          <select id="filterTier">
            <option value="">All</option><option>S</option><option>A</option><option>B</option><option>C</option><option>D</option>
          </select>
        </label>
        <label>Bye week
          <select id="filterBye">
            <option value="">All</option>
          </select>
        </label>
      </div>
      <small class="helper">Tier is a letter grade for overall quality. Bye week is when a player does not play.</small>
      <div class="row" style="margin-top:6px">
        <button class="btn" id="filterBtn">Apply</button>
        <button class="btn" id="clearFilterBtn">Clear</button>
      </div>
      <div id="results" class="list" style="margin-top:8px"></div>
    </div>

    <div class="panel">
      <h2>Position Scarcity</h2>
      <p class="tip">Shows how many players remain at each position. Bars fill as the pool dries up.</p>
      <div class="scarcity" id="scarcity"></div>
      <div class="divider"></div>
      <h2>Remaining Roster Needs</h2>
      <p class="tip">How many more starters you still need to fill.</p>
      <div id="needs" class="chips"></div>
    </div>
  </div>
</main>

<dialog id="how" style="max-width:720px;border:1px solid var(--border);border-radius:12px">
  <h2>How this works</h2>
  <p>This assistant builds a prioritized list for your next picks and an end-to-end plan. It estimates availability using ADP and a bell curve approximation. It also boosts or reduces players based on roster needs, tier breaks, positional scarcity, and your strategy toggles.</p>
  <ul>
    <li>Use <strong>Settings</strong> to enter league, roster, and strategy. Each field has a short description.</li>
    <li>Click <strong>Generate Plan</strong> to see your next two rounds and full lineup plan.</li>
    <li>Switch to <strong>Live Draft</strong> to log picks. The board updates and alerts on tier drops and snipe risk.</li>
    <li>Paste new data in the CSV box to replace the dataset. You can always reset to seed data.</li>
  </ul>
  <div class="row" style="justify-content:flex-end">
    <button class="btn" id="howClose">Close</button>
  </div>
</dialog>

<div id="toast" class="toast" style="display:none"></div>

<script>
/* =========================
   Seed dataset (compact real + synthetic to reach 240+)
   ========================= */
const seedTop = [
  { name: "Christian McCaffrey", team: "SF", position: "RB", byeWeek: 9, projectedPoints: 310, ADP: 1, tier: "S" },
  { name: "Justin Jefferson", team: "MIN", position: "WR", byeWeek: 6, projectedPoints: 295, ADP: 2, tier: "S" },
  { name: "Ja'Marr Chase", team: "CIN", position: "WR", byeWeek: 7, projectedPoints: 285, ADP: 3, tier: "S" },
  { name: "CeeDee Lamb", team: "DAL", position: "WR", byeWeek: 7, projectedPoints: 280, ADP: 4, tier: "S" },
  { name: "Breece Hall", team: "NYJ", position: "RB", byeWeek: 10, projectedPoints: 270, ADP: 5, tier: "S" },
  { name: "Bijan Robinson", team: "ATL", position: "RB", byeWeek: 12, projectedPoints: 265, ADP: 6, tier: "S" },
  { name: "Tyreek Hill", team: "MIA", position: "WR", byeWeek: 6, projectedPoints: 300, ADP: 7, tier: "S" },
  { name: "Amon-Ra St. Brown", team: "DET", position: "WR", byeWeek: 5, projectedPoints: 275, ADP: 8, tier: "S" },
  { name: "A.J. Brown", team: "PHI", position: "WR", byeWeek: 10, projectedPoints: 268, ADP: 9, tier: "S" },
  { name: "Jalen Hurts", team: "PHI", position: "QB", byeWeek: 10, projectedPoints: 380, ADP: 20, tier: "A" },
  { name: "Josh Allen", team: "BUF", position: "QB", byeWeek: 12, projectedPoints: 385, ADP: 22, tier: "A" },
  { name: "Patrick Mahomes", team: "KC", position: "QB", byeWeek: 10, projectedPoints: 365, ADP: 25, tier: "A" },
  { name: "Travis Kelce", team: "KC", position: "TE", byeWeek: 10, projectedPoints: 235, ADP: 19, tier: "A" },
  { name: "Sam LaPorta", team: "DET", position: "TE", byeWeek: 5, projectedPoints: 205, ADP: 35, tier: "A" },
  { name: "Lamar Jackson", team: "BAL", position: "QB", byeWeek: 14, projectedPoints: 360, ADP: 30, tier: "A" },
  { name: "Puka Nacua", team: "LAR", position: "WR", byeWeek: 6, projectedPoints: 250, ADP: 15, tier: "A" },
  { name: "Aidan O'Connell", team: "LV", position: "QB", byeWeek: 13, projectedPoints: 255, ADP: 180, tier: "C" }
];
const teams = ["SF","MIN","CIN","DAL","NYJ","ATL","MIA","DET","PHI","BUF","KC","BAL","LAC","LAR","SEA","JAX","HOU","PIT","CHI","GB","NO","TB","TEN","IND","NE","NYG","LV","ARI","CLE","WAS","CAR","DEN"];
const posDist = [
  {pos:"QB", count: 36, base: 290, drop: 2.6, tierCuts:[4,12,24]},
  {pos:"RB", count: 80, base: 220, drop: 1.8, tierCuts:[8,24,48,70]},
  {pos:"WR", count: 90, base: 210, drop: 1.7, tierCuts:[10,28,56,80]},
  {pos:"TE", count: 30, base: 170, drop: 1.5, tierCuts:[3,10,18,26]},
  {pos:"K",  count: 18, base: 140, drop: 1.2, tierCuts:[3,8,14]},
  {pos:"DST",count: 18, base: 130, drop: 1.1, tierCuts:[3,8,14]},
];
function synthPlayers(){
  const out = [...seedTop];
  let adp = 1;
  for(const cfg of posDist){
    for(let i=1;i<=cfg.count;i++){
      const name = `${cfg.pos} Player ${i}`;
      const team = teams[(i*7 + cfg.count) % teams.length];
      const byeWeek = 5 + ((i + cfg.count) % 10);
      const projectedPoints = Math.max(60, Math.round(cfg.base - cfg.drop*i + Math.random()*6));
      adp += 1;
      const tier = i<=cfg.tierCuts[0] ? "A" : i<=cfg.tierCuts[1] ? "B" : i<=cfg.tierCuts[2] ? "C" : (cfg.tierCuts[3] ? (i<=cfg.tierCuts[3] ? "D":"E") : "D");
      out.push({ name, team, position: cfg.pos, byeWeek, projectedPoints, ADP: adp, tier });
    }
  }
  out.sort((a,b)=>a.ADP-b.ADP).forEach((p,i)=>p.ADP = i+1);
  return out.slice(0, 250);
}
let players = synthPlayers();

/* =========================
   State
   ========================= */
const state = {
  players: JSON.parse(JSON.stringify(players)),
  removed: new Set(),
  locks: new Set(),
  picks: [],
  settings: {},
  plan: { next: null, alts: [], lineup: [] },
};
const els = {
  tabs: document.querySelectorAll('.tabbtn'),
  sections: {
    settings: document.getElementById('settings'),
    generate: document.getElementById('generate'),
    live: document.getElementById('live')
  },
  numTeams: document.getElementById('numTeams'),
  myPos: document.getElementById('myPos'),
  draftType: document.getElementById('draftType'),
  numRounds: document.getElementById('numRounds'),
  rosterCfg: document.getElementById('rosterCfg'),
  scoringPreset: document.getElementById('scoringPreset'),
  sigma: document.getElementById('sigma'),
  snipe: document.getElementById('snipeThresh'),
  picksTable: document.getElementById('picksTable').querySelector('tbody'),
  nextPick: document.getElementById('nextPick'),
  topAlt: document.getElementById('topAlt'),
  lineupPlan: document.getElementById('lineupPlan'),
  filter: {
    search: document.getElementById('filterSearch'),
    pos: document.getElementById('filterPos'),
    team: document.getElementById('filterTeam'),
    tier: document.getElementById('filterTier'),
    bye: document.getElementById('filterBye')
  },
  results: document.getElementById('results'),
  scarcity: document.getElementById('scarcity'),
  needs: document.getElementById('needs'),
  csvInput: document.getElementById('csvInput'),
  live: {
    search: document.getElementById('liveSearch'),
    pos: document.getElementById('livePos'),
    team: document.getElementById('liveTeam'),
    player: document.getElementById('livePlayer'),
    table: document.getElementById('liveTable').querySelector('tbody'),
    curRound: document.getElementById('curRound'),
    curPick: document.getElementById('curPick'),
    eta: document.getElementById('etaNext'),
    msg: document.getElementById('liveMsg'),
    next: document.getElementById('liveNext'),
    alt: document.getElementById('liveAlt'),
    alerts: document.getElementById('alerts'),
    teamIdx: document.getElementById('teamIdx')
  }
};

/* =========================
   Utils
   ========================= */
function toast(msg, ms=2200){ const t=document.getElementById('toast'); t.textContent=msg; t.style.display='block'; setTimeout(()=>t.style.display='none', ms); }
function approxNormCdf(x){
  const sign = x < 0 ? -1 : 1;
  x = Math.abs(x)/Math.SQRT2;
  const t = 1/(1+0.3275911*x);
  const a1=0.254829592,a2=-0.284496736,a3=1.421413741,a4=-1.453152027,a5=1.061405429;
  const erf = 1-((((a5*t+a4)*t+a3)*t+a2)*t+a1)*t*Math.exp(-x*x);
  return 0.5*(1+sign*erf);
}
function availabilityProb(ADP, pickNumber, sigma){
  const z = (pickNumber - ADP)/sigma;
  const c = approxNormCdf(z);
  const p = Math.max(0, Math.min(1, 1 - c));
  return p;
}
function computeMyPickNumbers(t, p, rounds, type="Snake"){
  const arr=[];
  for(let r=1;r<=rounds;r++){
    let overall;
    if(type==="Snake"){
      overall = (r%2===1) ? ((r-1)*t + p) : (r*t - p + 1);
    }else{
      overall = (r-1)*t + p;
    }
    arr.push({round:r, overall, pick:p});
  }
  return arr;
}
function getSettings(){
  const rosterInputs = els.rosterCfg.querySelectorAll('input');
  const roster = {};
  rosterInputs.forEach(i=>roster[i.dataset.pos] = parseInt(i.value||0));
  const preset = els.scoringPreset.value;
  const s = {
    numTeams: parseInt(els.numTeams.value||12),
    myPos: Math.min(parseInt(els.myPos.value||1), parseInt(els.numTeams.value||12)),
    draftType: els.draftType.value,
    numRounds: parseInt(els.numRounds.value||16),
    roster,
    scoring: {
      preset,
      passYdsPerPt: parseFloat(document.getElementById('passYdsPerPt').value),
      passTD: parseFloat(document.getElementById('passTD').value),
      int: parseFloat(document.getElementById('int').value),
      rushYdsPerPt: parseFloat(document.getElementById('rushYdsPerPt').value),
      rushTD: parseFloat(document.getElementById('rushTD').value),
      recYdsPerPt: parseFloat(document.getElementById('recYdsPerPt').value),
      rec: parseFloat(document.getElementById('rec').value),
      fumble: parseFloat(document.getElementById('fumble').value)
    },
    sigma: parseFloat(els.sigma.value||12),
    snipeThresh: parseFloat(els.snipe.value||30),
    strategies: Array.from(document.querySelectorAll('.strat:checked')).map(i=>i.value),
    stratWeights: {
      floor: parseFloat(document.getElementById('floorRange').value||1),
      upside: parseFloat(document.getElementById('upsideRange').value||1),
      rookie: parseFloat(document.getElementById('rookieRange').value||1)
    }
  };
  return s;
}
function countRosterTaken(plan){
  const count = {QB:0,RB:0,WR:0,TE:0,FLEX:0,K:0,DST:0,BENCH:0};
  plan.forEach(p=>{
    if(count[p.position] !== undefined) count[p.position]++;
    else count.BENCH++;
  });
  return count;
}
function remainingNeeds(roster, taken){
  const left = {};
  for(const k of Object.keys(roster)){
    left[k] = Math.max(0, roster[k] - (taken[k]||0));
  }
  return left;
}
function scarcityByPos(pool){
  const byPos = {QB:0,RB:0,WR:0,TE:0,K:0,DST:0};
  pool.forEach(p=>{ if(byPos[p.position]!==undefined) byPos[p.position]++; });
  return byPos;
}
function normalize(val, min, max){ if(max===min) return 0; return (val-min)/(max-min); }

/* =========================
   Scoring
   ========================= */
function scorePlayer(player, ctx){
  const { needs, sigma, nextOverallPick, strategies, stratWeights, plannedQBTeam } = ctx;
  const pool = ctx.pool;
  const posCounts = scarcityByPos(pool);
  const maxPts = Math.max(...pool.map(p=>p.projectedPoints));
  const minPts = Math.min(...pool.map(p=>p.projectedPoints));
  const base = normalize(player.projectedPoints, minPts, maxPts);

  const avail = availabilityProb(player.ADP, nextOverallPick, sigma);

  const want = (needs[player.position]||0) + (player.position==="RB"||player.position==="WR" ? (needs.FLEX||0)*0.5 : 0);
  const scarcity = 1 - normalize(posCounts[player.position], 0, Math.max(...Object.values(posCounts)));
  const scarcityBoost = 0.15*scarcity + 0.25*Math.min(1, want);

  const tierBonusMap = {S:0.25,A:0.18,B:0.12,C:0.07,D:0.03,E:0};
  const tierBonus = tierBonusMap[player.tier] || 0;

  let strat = 0;
  const isRookie = /Rookie|R\d/.test(player.name) || player.name.includes("(R)");
  const top20 = player.projectedPoints >= (minPts + 0.8*(maxPts-minPts));
  const floorWeight = strategies.includes('floor') ? stratWeights.floor : 0;
  const upsideWeight = strategies.includes('upside') ? stratWeights.upside : 0;
  const rookieWeight = strategies.includes('rookieTol') ? stratWeights.rookie : 0;
  strat += floorWeight * (player.tier==="S"||player.tier==="A" ? 0.12 : 0.05);
  strat += upsideWeight * (top20 ? 0.12 : 0);
  strat += rookieWeight * (isRookie ? 0.06 : 0);

  let posSkew = 0;
  if(strategies.includes('zeroRB') && (ctx.round<=6)){
    if(player.position==="WR"||player.position==="TE") posSkew += 0.1;
    if(player.position==="RB") posSkew -= 0.08;
  }
  if(strategies.includes('heroRB') && (ctx.round<=3)){
    if(player.position==="RB") posSkew += 0.1;
  }
  if(strategies.includes('lateQB') && (ctx.round<=7)){
    if(player.position==="QB") posSkew -= 0.08;
  }
  if(strategies.includes('balanced')) posSkew += 0.02;

  let stackBoost = 0;
  if(strategies.includes('stack') && plannedQBTeam && (player.position==="WR"||player.position==="TE")){
    if(player.team===plannedQBTeam) stackBoost += 0.08;
  }

  let score = base + scarcityBoost + tierBonus + strat + posSkew + stackBoost;
  score = score * (0.7 + 0.3*avail);

  const info = {
    base: base.toFixed(3),
    scarcityBoost: scarcityBoost.toFixed(3),
    tierBonus: tierBonus.toFixed(3),
    strat: strat.toFixed(3),
    posSkew: posSkew.toFixed(3),
    stack: stackBoost.toFixed(3),
    avail: avail.toFixed(3),
    total: score.toFixed(3)
  };
  return { score, avail, info };
}

/* =========================
   Recommendations and Plan
   ========================= */
function recommendNextPicks(pool, ctx){
  const scored = [];
  for(const p of pool){
    const s = scorePlayer(p, ctx);
    scored.push({...p, _score:s.score, _avail:s.avail, _info:s.info});
  }
  scored.sort((a,b)=>b._score - a._score);
  return scored;
}
function generateLineupPlan(pool, ctx){
  const roster = ctx.roster;
  const counts = {QB:0,RB:0,WR:0,TE:0,K:0,DST:0,BENCH:0};
  const picks = [];
  const maxPicks = ctx.numRounds;

  for(let r=1;r<=maxPicks;r++){
    const nextOverallPick = ctx.myPicks[r-1]?.overall ?? ((r-1)*ctx.numTeams + ctx.myPos);
    const needs = remainingNeeds(roster, counts);
    const plannedQBTeam = [...state.locks].map(n=>state.players.find(p=>p.name===n)).find(p=>p?.position==="QB")?.team;
    const rec = recommendNextPicks(pool.filter(x=>!state.locks.has(x.name)||true), {
      pool, needs, sigma:ctx.sigma, round:r, nextOverallPick, strategies:ctx.strategies, stratWeights:ctx.stratWeights, plannedQBTeam,
      roster, numTeams:ctx.numTeams, myPos:ctx.myPos, numRounds:ctx.numRounds, myPicks:ctx.myPicks
    });
    const pick = rec.find(p=>{
      if(needs[p.position]>0) return true;
      if(p.position==="RB"||p.position==="WR"||p.position==="TE"){
        if(needs.FLEX>0) return true;
      }
      return counts.BENCH < roster.BENCH;
    });
    if(!pick) break;
    picks.push({...pick, rationale:`Score ${pick._score.toFixed(2)}, avail ${(pick._avail*100|0)}%`});
    if(remainingNeeds(roster, counts)[pick.position]>0) counts[pick.position]++; else if((pick.position==="RB"||pick.position==="WR"||pick.position==="TE") && remainingNeeds(roster, counts).FLEX>0) counts.FLEX++; else counts.BENCH++;
    const idx = pool.findIndex(x=>x.name===pick.name);
    if(idx>=0) pool.splice(idx,1);
  }
  return picks;
}

/* =========================
   Live Draft
   ========================= */
function applyLivePick(name, teamIdx=1){
  const p = state.players.find(x=>x.name.toLowerCase()===name.toLowerCase());
  if(!p){ toast("Player not found"); return false; }
  if(state.removed.has(p.name)) { toast("Already drafted"); return false; }
  state.removed.add(p.name);
  const overall = state.picks.length + 1;
  state.picks.push({...p, overall, teamIdx});
  renderLive();
  recomputeAll();
  return true;
}

/* =========================
   Persistence
   ========================= */
function saveState(){
  const payload = {
    players: state.players,
    removed: Array.from(state.removed),
    locks: Array.from(state.locks),
    picks: state.picks,
    settings: getSettings(),
    plan: state.plan
  };
  localStorage.setItem('ff_draft_state_v1', JSON.stringify(payload));
  toast("Saved");
}
function loadState(){
  const raw = localStorage.getItem('ff_draft_state_v1');
  if(!raw){ toast("Nothing saved yet"); return; }
  try{
    const data = JSON.parse(raw);
    state.players = data.players;
    state.removed = new Set(data.removed||[]);
    state.locks = new Set(data.locks||[]);
    state.picks = data.picks||[];
    state.plan = data.plan||{};
    toast("Loaded");
    recomputeAll();
  }catch(e){ toast("Load failed"); }
}

/* =========================
   CSV Import / Export
   ========================= */
function parseCSV(text){
  const lines = text.trim().split(/\r?\n/);
  if(!lines.length) throw new Error("Empty CSV");
  const header = lines[0].split(',').map(s=>s.trim());
  const expect = ["name","team","position","byeWeek","projectedPoints","ADP","tier"];
  const miss = expect.filter(k=>!header.includes(k));
  if(miss.length) throw new Error("Missing columns: "+miss.join(', '));
  const idx = Object.fromEntries(header.map((h,i)=>[h,i]));
  const out = [];
  for(let r=1;r<lines.length;r++){
    const row = lines[r].split(',');
    if(row.length !== header.length) throw new Error(`Row ${r+1} has ${row.length} columns`);
    const obj = {
      name: row[idx.name].trim(),
      team: row[idx.team].trim(),
      position: row[idx.position].trim().toUpperCase(),
      byeWeek: parseInt(row[idx.byeWeek]),
      projectedPoints: parseFloat(row[idx.projectedPoints]),
      ADP: parseInt(row[idx.ADP]),
      tier: row[idx.tier].trim()
    };
    if(!obj.name || !obj.team || !/^(QB|RB|WR|TE|K|DST)$/.test(obj.position)) throw new Error(`Row ${r+1} invalid name/team/position`);
    if(Number.isNaN(obj.byeWeek) || Number.isNaN(obj.projectedPoints) || Number.isNaN(obj.ADP)) throw new Error(`Row ${r+1} invalid numbers`);
    out.push(obj);
  }
  out.sort((a,b)=>a.ADP-b.ADP).forEach((p,i)=>p.ADP = i+1);
  return out;
}
function exportPlayersCSV(list){
  const header = "name,team,position,byeWeek,projectedPoints,ADP,tier";
  const rows = list.map(p=>[p.name,p.team,p.position,p.byeWeek,p.projectedPoints,p.ADP,p.tier].join(','));
  const blob = new Blob([header+"\n"+rows.join("\n")], {type:"text/csv"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download="players.csv"; a.click(); URL.revokeObjectURL(url);
}
function exportPlanJSON(){
  const blob = new Blob([JSON.stringify(state.plan, null, 2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download="plan.json"; a.click(); URL.revokeObjectURL(url);
}
function exportRecommendationsCSV(){
  const header = "name,team,position,byeWeek,ADP,projectedPoints,score,availability";
  const rows = (state.plan?.alts||[]).map(p=>[p.name,p.team,p.position,p.byeWeek,p.ADP,p.projectedPoints,p._score.toFixed(3),(p._avail*100).toFixed(1)+"%"].join(','));
  const blob = new Blob([header+"\n"+rows.join("\n")], {type:"text/csv"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download="recommendations.csv"; a.click(); URL.revokeObjectURL(url);
}

/* =========================
   Rendering helpers
   ========================= */
function badge(text){ return `<span class="badge">${text}</span>`; }
function probBar(p){ return `<div class="probbar" title="Avail ${(p*100).toFixed(1)}%"><span style="width:${(p*100).toFixed(1)}%"></span></div>`; }
function itemRow(p, ctx, lockable=true){
  const posClass = `pos-${p.position}`;
  const info = p._info ? `<details><summary>score info</summary>
    <div class="twocol">
      <div>base: ${p._info.base}</div><div>scarcity: ${p._info.scarcityBoost}</div>
      <div>tier: ${p._info.tierBonus}</div><div>strategy: ${p._info.strat}</div>
      <div>posSkew: ${p._info.posSkew}</div><div>stack: ${p._info.stack}</div>
      <div>avail: ${p._info.avail}</div><div><b>total: ${p._info.total}</b></div>
    </div></details>` : '';
  const locked = state.locks.has(p.name);
  return `<div class="item ${locked?'hl':''}">
    <div>
      <div class="meta">
        <strong>${p.name}</strong>
        <span class="chip ${posClass}">${p.position}</span>
        <div class="badges">
          ${badge(p.team)}
          ${badge("Tier "+p.tier)}
          ${badge("Bye "+p.byeWeek)}
          ${badge("ADP "+p.ADP)}
          ${badge(p.projectedPoints+" pts")}
        </div>
      </div>
      <div style="margin-top:6px;display:grid;grid-template-columns:1fr 160px;gap:8px;align-items:center">
        ${probBar(p._avail ?? availabilityProb(p.ADP, ctx.nextOverallPick||1, ctx.sigma))}
        <div style="text-align:right" class="muted">Score ${(p._score??0).toFixed(2)}</div>
      </div>
      ${p.rationale ? `<div class="muted" style="margin-top:6px">${p.rationale}</div>`:''}
      ${info}
    </div>
    <div class="row" style="align-self:start">
      ${lockable?`<button class="btn sm lock" data-name="${p.name}">${locked?'Unlock':'Lock'}</button>`:''}
      <button class="btn sm" data-addlive="${p.name}">Drafted</button>
    </div>
  </div>`;
}

/* =========================
   Main recompute
   ========================= */
function recomputeAll(){
  const pool = state.players.filter(p=>!state.removed.has(p.name));
  fillDropdowns();
  renderFilterResults();
  const s = getSettings();
  els.myPos.max = s.numTeams;
  const myPicks = computeMyPickNumbers(s.numTeams, s.myPos, s.numRounds, s.draftType);
  renderPicksTable(myPicks);
  const taken = countRosterTaken(state.plan?.lineup||[]);
  const needs = remainingNeeds(s.roster, taken);
  renderScarcity(pool, needs);
  const draftedCount = state.picks.length;
  const currentOverall = draftedCount + 1;
  const currentRound = Math.floor((currentOverall-1) / s.numTeams) + 1;
  const myNextPick = myPicks.find(pk=>pk.overall >= currentOverall) || myPicks[myPicks.length-1];
  const ctx = {
    roster: s.roster, numTeams: s.numTeams, myPos: s.myPos, numRounds: s.numRounds,
    sigma: s.sigma, strategies: s.strategies, stratWeights: s.stratWeights,
    myPicks, nextOverallPick: myNextPick.overall, round: currentRound, pool,
    needs, plannedQBTeam: ([...state.locks].map(n=>state.players.find(p=>p.name===n)).find(p=>p?.position==="QB")||{}).team
  };
  const rec = recommendNextPicks(pool, ctx);
  state.plan.next = rec[0];
  state.plan.alts = rec.slice(1, 11);
  const plan = generateLineupPlan(pool.slice(), {...ctx});
  state.plan.lineup = plan;

  renderNext(rec[0], rec.slice(1,10), ctx);
  renderLineupPlan(plan);
  renderLiveMeta();
}
function renderPicksTable(myPicks){
  els.picksTable.innerHTML = myPicks.map(pk=>`<tr><td>${pk.round}</td><td>${pk.pick}</td><td>${pk.overall}</td></tr>`).join('');
}
function renderNext(best, alts, ctx){
  els.nextPick.innerHTML = best ? itemRow(best, ctx) : `<div class="muted">No candidates</div>`;
  els.topAlt.innerHTML = alts.map(p=>itemRow(p, ctx)).join('') + `<div class="row"><button class="btn" id="exportRecBtn">Export CSV of recommended picks</button></div>`;
}
function renderLineupPlan(plan){
  els.lineupPlan.innerHTML = plan.map((p,i)=> `<div class="item">
    <div>
      <div class="meta"><strong>Round ${i+1} - ${p.name}</strong></div>
      <div class="badges" style="margin-top:4px">
        ${badge(p.position)} ${badge(p.team)} ${badge("Tier "+p.tier)} ${badge("Bye "+p.byeWeek)} ${badge("ADP "+p.ADP)}
      </div>
      <div class="muted" style="margin-top:6px">${p.rationale||''}</div>
    </div>
    <div class="row">
      <button class="btn sm lock" data-name="${p.name}">${state.locks.has(p.name)?'Unlock':'Lock'}</button>
      <button class="btn sm" data-addlive="${p.name}">Drafted</button>
    </div>
  </div>`).join('');
}
function renderScarcity(pool, needs){
  els.needs.innerHTML = Object.entries(needs).filter(([k])=>k!=="BENCH").map(([k,v])=>`<span class="chip"><b>${k}</b> need ${v}</span>`).join('');
  const counts = scarcityByPos(pool);
  const max = Math.max(...Object.values(counts));
  const blocks = Object.entries(counts).map(([pos,c])=>{
    const urg = needs[pos]>0 ? 'color:var(--bad);font-weight:700' : 'color:var(--muted)';
    const pct = Math.round((1 - c/max)*100);
    return `<div class="scar">
      <div class="inline" style="justify-content:space-between">
        <strong>${pos}</strong>
        <span style="${urg}">${needs[pos]||0} needed</span>
      </div>
      <div class="bar" title="Scarcity ${pct}%"><span style="width:${pct}%"></span></div>
      <small class="muted">${c} remaining in pool</small>
    </div>`;
  }).join('');
  els.scarcity.innerHTML = blocks;
}
function renderFilterResults(){
  const q = els.filter.search.value.trim().toLowerCase();
  const pos = els.filter.pos.value;
  const team = els.filter.team.value;
  const tier = els.filter.tier.value;
  const bye = els.filter.bye.value;
  const list = state.players.filter(p=>{
    if(state.removed.has(p.name)) return false;
    if(q && !(p.name.toLowerCase().includes(q)||p.team.toLowerCase().includes(q))) return false;
    if(pos && p.position!==pos) return false;
    if(team && p.team!==team) return false;
    if(tier && p.tier!==tier) return false;
    if(bye && String(p.byeWeek)!==String(bye)) return false;
    return true;
  }).slice(0, 50);
  const s = getSettings();
  const myPicks = computeMyPickNumbers(s.numTeams, s.myPos, s.numRounds, s.draftType);
  const draftedCount = state.picks.length;
  const nextPickOverall = (myPicks.find(pk=>pk.overall >= draftedCount+1) || myPicks[myPicks.length-1]).overall;
  els.results.innerHTML = list.map(p=>itemRow({...p, _score:0, _avail:availabilityProb(p.ADP, nextPickOverall, s.sigma)}, {nextOverallPick:nextPickOverall, sigma:s.sigma})).join('');
}
function fillDropdowns(){
  const allTeams = Array.from(new Set(state.players.map(p=>p.team))).sort();
  const teamOpts = ['<option value="">All</option>'].concat(allTeams.map(t=>`<option>${t}</option>`)).join('');
  els.filter.team.innerHTML = teamOpts;
  els.live.team.innerHTML = ['<option value="">Any</option>'].concat(allTeams.map(t=>`<option>${t}</option>`)).join('');
  els.livePlayer.innerHTML = buildLiveSelect();
  const byeSet = Array.from(new Set(state.players.map(p=>p.byeWeek))).sort((a,b)=>a-b);
  els.filter.bye.innerHTML = ['<option value="">All</option>'].concat(byeSet.map(b=>`<option>${b}</option>`)).join('');
}
function buildLiveSelect(){
  const pos = els.live.pos.value;
  const team = els.live.team.value;
  const pool = state.players.filter(p=>!state.removed.has(p.name));
  const list = pool.filter(p=>{
    if(pos && p.position!==pos) return false;
    if(team && p.team!==team) return false;
    return true;
  }).slice(0, 200);
  return list.map(p=>`<option>${p.name} — ${p.team} ${p.position}</option>`).join('');
}
function renderLive(){
  els.live.table.innerHTML = state.picks.map((p,i)=>`<tr>
    <td>${i+1}</td><td>${p.name}</td><td>${p.team}</td><td>${p.position}</td><td>${p.byeWeek}</td><td>${p.overall}</td>
    <td><button class="btn sm" data-undo="${p.name}">Undo</button></td>
  </tr>`).join('');
  els.live.player.innerHTML = buildLiveSelect();
}
function renderLiveMeta(){
  const s = getSettings();
  const draftedCount = state.picks.length;
  const curOverall = draftedCount + 1;
  const curRound = Math.floor((curOverall-1)/s.numTeams)+1;
  const myPicks = computeMyPickNumbers(s.numTeams, s.myPos, s.numRounds, s.draftType);
  const myNext = myPicks.find(pk=>pk.overall >= curOverall) || myPicks[myPicks.length-1];
  const delta = myNext.overall - draftedCount;
  els.live.curRound.textContent = curRound;
  els.live.curPick.textContent = curOverall;
  els.live.eta.textContent = delta>0 ? `${delta} picks` : "Now";
  const pool = state.players.filter(p=>!state.removed.has(p.name));
  const needs = remainingNeeds(s.roster, countRosterTaken(state.plan?.lineup||[]));
  const ctx = { roster:s.roster, numTeams:s.numTeams, myPos:s.myPos, numRounds:s.numRounds,
    sigma:s.sigma, strategies:s.strategies, stratWeights:s.stratWeights,
    myPicks, nextOverallPick: myNext.overall, round: curRound, pool, needs,
    plannedQBTeam: ([...state.locks].map(n=>state.players.find(p=>p.name===n)).find(p=>p?.position==="QB")||{}).team
  };
  const rec = recommendNextPicks(pool, ctx);
  els.live.next.innerHTML = rec[0] ? itemRow(rec[0], ctx) : `<div class="muted">No candidates</div>`;
  els.live.alt.innerHTML = rec.slice(1,7).map(p=>itemRow(p, ctx)).join('');

  const snipe = s.snipeThresh/100;
  const risk = rec.filter(p=>p._avail < snipe).slice(0,3);
  const tiersLeft = {};
  pool.forEach(p=>{
    tiersLeft[p.position] = tiersLeft[p.position] || {};
    tiersLeft[p.position][p.tier] = (tiersLeft[p.position][p.tier]||0)+1;
  });
  const tierAlerts = Object.entries(tiersLeft).flatMap(([pos,tiers])=>{
    return Object.entries(tiers).filter(([tier,count])=>count<=2 && ["S","A"].includes(tier)).map(([tier,count])=>`<div class="alert">Tier ${tier} at ${pos} almost gone - ${count} left</div>`);
  }).join('');
  els.live.alerts.innerHTML = (risk.length?`<div class="alert">Snipe risk: ${risk.map(r=>r.name).join(', ')}</div>`:'') + tierAlerts;
}

/* =========================
   Events
   ========================= */
document.getElementById('generateBtn').addEventListener('click', ()=>{
  recomputeAll();
  switchTab('generate');
});
document.getElementById('exportJsonBtn').addEventListener('click', exportPlanJSON);
document.addEventListener('click', e=>{
  const btn = e.target.closest('.lock');
  if(btn){
    const name = btn.dataset.name;
    if(state.locks.has(name)) state.locks.delete(name); else state.locks.add(name);
    btn.textContent = state.locks.has(name)?'Unlock':'Lock';
    recomputeAll();
  }
  const add = e.target.closest('[data-addlive]');
  if(add){
    const name = add.dataset.addlive;
    if(applyLivePick(name, parseInt(els.live.teamIdx.value||1))) {
      toast(`Drafted ${name}`);
    }
  }
  const undo = e.target.closest('[data-undo]');
  if(undo){
    const name = undo.dataset.undo;
    const idx = state.picks.findIndex(p=>p.name===name);
    if(idx>=0){
      state.picks.splice(idx,1);
      state.removed.delete(name);
      renderLive();
      recomputeAll();
    }
  }
  if(e.target.id==='exportRecBtn') exportRecommendationsCSV();
});
document.getElementById('filterBtn').addEventListener('click', renderFilterResults);
document.getElementById('clearFilterBtn').addEventListener('click', ()=>{
  els.filter.search.value=''; els.filter.pos.value=''; els.filter.team.value=''; els.filter.tier.value=''; els.filter.bye.value='';
  renderFilterResults();
});
['numTeams','myPos','draftType','numRounds','sigma','snipeThresh','scoringPreset'].forEach(id=>{
  document.getElementById(id)?.addEventListener('change', recomputeAll);
});
els.rosterCfg.addEventListener('change', recomputeAll);
document.querySelectorAll('.strat, #floorRange, #upsideRange, #rookieRange').forEach(x=>x.addEventListener('change', recomputeAll));
els.filter.search.addEventListener('input', ()=>{ renderFilterResults(); });
['livePos','liveTeam'].forEach(id=>{
  document.getElementById(id).addEventListener('change', ()=>{
    els.live.player.innerHTML = buildLiveSelect();
  });
});
document.getElementById('addLiveBtn').addEventListener('click', ()=>{
  const q = els.live.search.value.trim();
  if(!q){ toast("Type a name"); return; }
  if(applyLivePick(q, parseInt(els.live.teamIdx.value||1))){
    els.live.search.value='';
  } else {
    els.live.msg.textContent = "Not found or already drafted";
    setTimeout(()=>els.live.msg.textContent='', 2000);
  }
});
document.getElementById('addLiveSelBtn').addEventListener('click', ()=>{
  const opt = els.live.player.value;
  const name = opt.split(' — ')[0];
  applyLivePick(name, parseInt(els.live.teamIdx.value||1));
});
document.getElementById('saveBtn').addEventListener('click', saveState);
document.getElementById('loadBtn').addEventListener('click', loadState);
document.getElementById('hardResetBtn').addEventListener('click', ()=>{
  if(confirm("Clear all picks and changes")) {
    state.players = synthPlayers();
    state.removed = new Set();
    state.locks = new Set();
    state.picks = [];
    state.plan = { next:null, alts:[], lineup:[] };
    recomputeAll();
  }
});
document.getElementById('resetSeedBtn').addEventListener('click', ()=>{
  state.players = synthPlayers();
  state.removed = new Set();
  toast("Reset to seed data");
  recomputeAll();
});
document.getElementById('importCsvBtn').addEventListener('click', ()=>{
  try{
    const text = els.csvInput.value;
    const list = parseCSV(text);
    state.players = list;
    state.removed = new Set();
    state.locks = new Set();
    state.picks = [];
    toast(`Imported ${list.length} players`);
    recomputeAll();
  }catch(e){
    toast("CSV error: "+e.message, 4000);
  }
});
document.getElementById('exportCsvSeedBtn').addEventListener('click', ()=>exportPlayersCSV(state.players));
function switchTab(id){
  els.tabs.forEach(b=>{
    const active = b.dataset.tab===id;
    b.classList.toggle('active', active);
    b.setAttribute('aria-selected', active?'true':'false');
  });
  Object.entries(els.sections).forEach(([k,sec])=>sec.classList.toggle('active', k===id));
}
els.tabs.forEach(b=>b.addEventListener('click', ()=>switchTab(b.dataset.tab)));

document.getElementById('howBtn').addEventListener('click', ()=>{
  document.getElementById('how').showModal();
  document.getElementById('howBtn').setAttribute('aria-expanded','true');
});
document.getElementById('howClose').addEventListener('click', ()=>{
  document.getElementById('how').close();
  document.getElementById('howBtn').setAttribute('aria-expanded','false');
});

/* Keyboard focus for accessibility */
document.addEventListener('keydown', e=>{
  if(e.key==='/' && document.activeElement.tagName!=='INPUT' && document.activeElement.tagName!=='TEXTAREA'){
    e.preventDefault(); els.filter.search.focus();
  }
});

/* =========================
   Init
   ========================= */
function init(){
  fillDropdowns();
  recomputeAll();
}
init();
</script>
</body>
</html>
